/*===================================================
      复制头文件的库说明文档，并做详细展开

 ====================================================*/

//====================================================
//	数据结构定义
//====================================================
    #include "lock.h"
    
//====================================================
//	API
//====================================================
/*   核心：1、假定每一步操作都不是原子操作 
              则：上锁途中-->抢占-->读锁，结果为没有上锁

           2、要能判断出 ： 判断是否上锁 到 执行流程中间是否被打断过
              被打断过，则上锁失败，返回有锁，等待解锁
           3、情境模拟：
            //打断上锁1：
            高优先级            低优先级
                                if(锁1)
                                锁1上锁        //假定每一步操作都不是原子操作
            if(锁1) 
            锁1上锁
            锁2上锁
            执行xxx
                                锁2是否上锁？：被打断则可以检测出锁2也被上锁
                                执行xxx（必须等待解锁后才可以再次执行）
            
            执行xxx:
            ·比如设定发送数组，如果数组1还没有发送完成，就修改为了数组2，则出现bug
            
            //打断上锁2
            高优先级会在 if(锁1) 这一步返回
===========================================================================*/
    //读取是否上锁，如果没有上锁，则上锁，并返回1           
    uint8 read_and_lock(type_mylock* lock)
    {
        if(lock->value1 == 0x55)
        {
            return 0;
        }
        lock->value1 = 0x55;
        if(lock->value2 == 0x55)
        {
            return 0; 
        }
        lock->value2 = 0x55;
        return 1;
    }
    //解锁时也可能被打断
    //解锁，释放资源的访问权，或解除流程互锁
    uint8 unlock(type_mylock* lock)
    {
        lock->value2 = 0x00;         //先解锁2，因为上锁时先读取锁1的状态
        if(lock->value2 == 0x00)      //这里加入查询是为了保证解锁顺序，防止程序优化导致顺序颠倒
        {
            lock->value1 = 0x00;
        }
		return true;
    }

    //

