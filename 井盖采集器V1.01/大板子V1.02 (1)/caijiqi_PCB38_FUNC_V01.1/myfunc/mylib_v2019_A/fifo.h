#ifndef fifo_h
#define fifo_h

/*=============================================================
   库说明文档：     先进先出队列库  fifo.h    
   版本：	       v2019_A_02.h
   更新：  v2019_A_01 更新日期：2019.6.16
          基于原先的fifo.c和fifo.h
          过去的fifo结构体中将fifo操作作为函数指针包含了进来，本意是构建 fifo1.add(8)这样简洁的函数。
          实际编写无法实现上述简洁的方式。新版本去掉了这些函数指针。
          当前API：（省略返回值和参数）
            fifo_init()             初始化
            fifo_add_to_botton()    尾部追加数据
            fifo_add_multi_to_bottom()  尾部追加多个数据
            fifo_add_to_top()       头部追加数据
            fifo_read()             从fifo中读取一个数据
            fifo_sub()              从fifo中读取并删除一个数据
            fifo_sub_multi()        从fifo中读取并删除多个数据
            fifo_to_array()         将fifo元素输出到数组        
            fifo_reset()            清空fifo，但不清空table数据(实际使用中无需清空)
            fifo_clear()            清空fifo，同时清空table数据
          v2019_A_02 更新时间：2019.06.17 
            在fifo的库函数中，去掉了上锁和解锁步骤。
            ☆ -- fifo处理往往只是数据处理的一个环节，有时候需要对整个环节上锁解锁处理（使用全局中断控制）
               如果在fifo内使用了全局中断控制，则其他环节可能就无法得到锁的保护。
            ☆ 所以fifo使用时的上锁和解锁操作需要编程人员手动添加
              -- 使用锁还是其他保护方式的考虑因素：
                 （1）是否需要维持数据完整性，如果中断中调用了fifo处理，且不能错过，则一般的互斥锁则可能不适合
                     （上锁期间，中断函数无法进行fifo处理，程序又无法返回main中执行完fifo处理，只能放弃中断函数的本次fifo处理）
                 （2）线程间的关系，
         v2019_A_03 更新时间：2019.8.8
            去掉 fifo状态指示，使用 c_use c_unuse 来作为外部接口
         v2019_A_04 更新时间：2019.8.13
            去掉了p_read,
            fifo_read()功能改为：将fifo作为一个数组看待时，返回fifo[n]（n从0开始）
            fifo_to_array，参数：legnth大于c_used时，全部读出
   功能： 
   内容： 数据类型 + 对外变量 + 函数 
   环境： 单片机
   依赖： 库 / os / 其他
          - 依赖数据类型库（uint8 的定义）
   限制： 功能限制、性能限制、参数限制 ……
          - 当前版本只做了uint8的fifo库
            如果想实现特定数据类型(int,float,结构体)的fifo库，则需要另外编写，或用uint8的fifo库模拟（n个字节的出库入库）
            
   可改进点：如果想实现 fifo.add(2),fifo.sub()这种格式的类似C#的API机制，
            (1)使用宏能否实现
            (2)在fifo中增加函数指针，并需要一定的动态机制，在创建fifo时，动态的创建出与之对应的函数
               然后赋值给fifo的结构体指针。
   使用注意事项： 重入 / 资源保护 / 存储保护 /条件判断
          - fifo缓冲经常用于跨线程的操作中
            比如通信中，uart接收(入fifo) ，main中的uart数据处理(出fifo)，两者其实处于不同的线程。
            线程无抢占关系时，可以专门的互斥锁，保证操作时不会被打断
            如果有抢占关系，建议使用关中断操作，避免高优先级打断低优先线程，而因为锁的关系，无法执行入队出队操作，从而导致数据丢失的问题。

 ==============================================================*/

//==============================================================
//	依赖关系：
//==============================================================
    #include "typedef.h"   //使用里面的基本数据类型定义(uint8,uint16,uint32之类的)
    
    //为了保证fifo操作的原子性，避免访问冲突，需要对操作上锁和解锁
    //可用上锁方式：使用 锁相关的库，或者使用总中断的开关
    

//==============================================================
//	数据结构类型定义
//==============================================================
           
//==============================================================
//	对外数据声明
//==============================================================

    typedef struct type_fifo type_fifo;             		//超前声明	
    struct type_fifo{
        uint16          length;                                 //缓冲数组长度
        uint16 		    c_used;							        //队列当前长度
        uint16          c_unused;                               //剩余空间
        uint16 		    p_add;                       	        //add指针
        uint16 		    p_sub;                        	        //sub指针
        uint8*          table;				                    //缓冲数组
    };
    
    #define new_fifo(x,y)  uint8 table_##x[(y)];        \
                           type_fifo        x={         \
                                sizeof(table_##x),      \
                                0,                      \
                                sizeof(table_##x),      \
                                0,                      \
                                0,                      \
                                table_##x               \
                           } 
    #define new_static_fifo(x,y)  static uint8 table_##x[(y)];    \
                    static type_fifo        x={         \
                                sizeof(table_##x),      \
                                0,                      \
                                sizeof(table_##x),      \
                                0,                      \
                                0,                      \
                                table_##x               \
                           } 
//==============================================================
//	API
//==============================================================
    
    //===========================================================
    //  功能：初始化fifo
    //  参数：fifo:fifo结构体指针
    //        table:  缓冲数组
    //        length: 缓冲数组长度  
    //===========================================================    
    void fifo_init(type_fifo* fifo,uint8* table,uint16 length);

    //====================================================
    //	功能：在队列尾部追加一个数据
    //        如果队列满，则追加的数据会覆盖第一个数据  
    //  参数：type_fifo*：队列结构体
    //        x         ：追加的数据
    //  使用注意：   必须先初始化fifo，才可进行fifo写操作
    //               否则会因为table指针未初始化造成bug
    //====================================================

    void fifo_add_to_bottom(type_fifo* fifo,uint8 x);

    //多个数据入队
    void fifo_add_multi_to_bottom(type_fifo* fifo,uint8*x,uint16 n);
    //====================================================
    //	功能：在队列头部插入一个数据
    //        如果队列满，则追加的数据会覆盖最后一个数据  
    //  参数：type_fifo*：队列结构体
    //        x         ：追加的数据
    //  使用注意：   必须先初始化fifo，才可进行fifo写操作
    //               否则会因为table指针未初始化造成bug
    //====================================================    
    void fifo_add_to_top(type_fifo* fifo,uint8 x);
    
    //====================================================
    //	功能：从fifo中读取一个数据但不删除
    //        
    //  参数：type_fifo*：队列结构体
    //  返回值：     读取到的数据
    //               注：fifo为空时，返回0
    //  使用注意：(1)必须先初始化fifo，才可进行fifo写操作
    //               否则会因为table指针未初始化造成bug
    //            (2)使用时配合FIFO状态检测，
    //            (3)读取时，借助fifo.c_used 来保证读取到的是队列中的数据
    //===================================================

    uint8 fifo_read(type_fifo* fifo,uint16 num);
    
    //====================================================
    //	功能：从fifo读取并删除一个数据
    //        
    //  参数：type_fifo*：队列结构体
    //  返回值：     读取到的数据
    //               注：fifo为空时，返回0
    //  使用注意：(1)必须先初始化fifo，才可进行fifo写操作
    //               否则会因为table指针未初始化造成bug
    //            (2)使用时配合FIFO状态检测，
    //            (3)读取时，借助fifo.c_used 来保证读取到的是队列中的数据
    //===================================================
    uint8 fifo_sub(type_fifo* fifo);
    //同时出栈多个数据到数组
    uint8 fifo_sub_multi(type_fifo* fifo,uint8* x,uint16 n);
    //====================================================
    //	功能：Fifo内元素复制到数组中
    //  参数：type_fifo*：  队列结构体
    //        table:        输出的数组首地址
    //        length:       需要复制的元素数，为0表示全部复制出来
    //  返回值：     无
    //  使用注意：(1)必须先初始化fifo，才可进行fifo写操作
    //               否则会因为table指针未初始化造成bug
    //            (2)此函数有数组访问溢出风险
    //               使用时先保证table长度足够存放从fifo中读取出的数据
    //===================================================
    void fifo_to_array(type_fifo* fifo,uint8* table,uint16 length );
    
    //===========================================================
    //  功能：清空fifo，但不清理table数据
    //  参数：fifo结构体指针
    //  使用说明：此操作fifo的read和sub指针复位到add指针处，并对状态和空间做清空处理
    //            此操作并不清理table数据
    //            程序中清空fifo建议使用此API
    //===========================================================
    void fifo_reset(type_fifo* fifo);
    
    //===========================================================
    //  功能：清空fifo，并清理table数据
    //  参数：fifo结构体指针
    //  使用说明：此操作将所有内部变量清零(c_unused除外)
    //            并清理 table数据为 0
    //            在debug时可以使用此函数，方便查看fifo中的数据
    //===========================================================
    void fifo_clear(type_fifo* fifo);


//============================ END =======================================






#endif
